#include <algorithm>
#include <fstream>
#include <iostream>
#include <iterator>
#include <stack>
#include <unordered_map>

#include "magic_enum.hpp"
#include "pivot/script/Exceptions.hxx"
#include "pivot/script/Parser.hxx"
#include <cpplogger/Logger.hpp>
#include <pivot/pivot.hxx>

namespace pivot::ecs::script::parser
{

const std::string gKnownSymbols = "+-/*%=!()<>,.#&|\" \t\r\n";
const std::unordered_map<std::string, Precedence> gOneCharOps = {
    {"/", Precedence::Multiplicative}, {"*", Precedence::Multiplicative}, {"%", Precedence::Multiplicative},
    {"+", Precedence::Additive},       {"-", Precedence::Additive},       {"<", Precedence::Relational},
    {">", Precedence::Relational}};
const std::unordered_map<std::string, Precedence> gTwoCharOps = {
    {">=", Precedence::Relational}, {"<=", Precedence::Relational}, {"==", Precedence::Equality},
    {"!=", Precedence::Equality},   {"&&", Precedence::LogicalAnd}, {"||", Precedence::LogicalOr}};
const std::vector<std::string> gBlockops = {"if", "while"};
const std::unordered_map<std::string, data::BasicType> gVariableTypes{{"Vector3", data::BasicType::Vec3},
                                                                      {"Number", data::BasicType::Number},
                                                                      {"Boolean", data::BasicType::Boolean},
                                                                      {"Color", data::BasicType::Number},
                                                                      {"String", data::BasicType::String}};

// Public methods

/*	Abstract Syntax Tree (AST) generator function
        This will use tokens generated by the lexer to build a tree of nodes representing the file
        Nodes are defined by their type :
                File:						Top node containing children nodes
                Component Declaration:		A node containing the declaration of a component
                System Declaration:		A node containing the declaration of a System		*/
Node Parser::ast_from_file(const std::string &file, bool isContent, bool verbose)
{
    DEBUG_FUNCTION();
    Node result = {.type = NodeType::File, .value = file};
    // Fill _tokens with the tokens from the file
    tokens_from_file(file, isContent, verbose);
    // Consume all tokens
    while (!_tokens.empty()) {
        // Here we expect a list of component or system declarations, and nothing else
        Token &t = _tokens.front();
        if (t.type != TokenType::Identifier) {    // Expect an identifier
            logger.err("ERROR") << " at line " << t.line_nb << " char " << t.char_nb << ": '" << t.value << "'";
            throw UnexpectedTokenTypeException("Expected Identifier token");
        }
        // Depending on if it is a component or a system token, call the correct callback to consume the
        // tokens and create a node representing the declaration
        else if (t.value == "component")
            result.children.push_back(consumeComponent());
        else if (t.value == "system")
            result.children.push_back(consumeSystem());
        else if (t.value == "event")
            result.children.push_back(consumeEvent());
        else {    // neither an identifier, a component nor a system
            logger.err("ERROR") << " at line " << t.line_nb << " char " << t.char_nb << ": '" << t.value << "'";
            throw UnexpectedTokenTypeException("Expected 'component', 'system' or 'event' token.");
        }
    }
    if (verbose) printFileNode(result);
    return result;    // valid node
}

/* Lexer function
        This will fill the _tokens variable with the list of all tokens in the file, in the order they appear
        A token is defined as any string of characters which are either
                Whitespace:		space, tab, \r or \n
                Known symbols:	+ - * / % = ! ( ) < > . # "
                Neither of the two above		*/
void Parser::tokens_from_file(const std::string &file, bool isContent, bool verbose)
{
    DEBUG_FUNCTION();
    std::string text = "";
    if (isContent) {
        text = file;
    } else {
        // Read file
        std::ifstream ifs(file);
        if (!ifs.is_open()) {
            std::cerr << "FileSystemError : couldn't open file " << file << std::endl;
            return;
        }
        text = std::string(std::istreambuf_iterator<char>{ifs}, {});
    }

    // Detect indent type of file (to then insert Indent and Dedent tokens and ignore all whitespace afterthat)
    IndentType indentType = indent_type_of(text);
    size_t indentSize = indent_size_of(text);
    if (verbose) logger.info("Indent for ") << file << ": " << indentSize << " " << magic_enum::enum_name(indentType);
    // std::cout << std::format("Indent for {}: {} {}", file, indentSize, magic_enum::enum_name(indentType)) <<
    // std::endl; // format not available in c++20 gcc yet

    // Clear _tokens variable (new assign more efficient than .pop() loop ?)
    _tokens = {};
    // Indices for navigating file string
    size_t lineNb = 1;
    size_t lastLineIndentSize = 0;
    size_t lineStart = 0;
    size_t lineEnd = text.find('\n', lineStart);
    bool shouldBreak = false;

    while (!shouldBreak) {                     // loop over every line
        if (lineEnd == std::string::npos) {    // TODO : handle last line more elegantly ?
            lineEnd = text.size();             // last line of file
            shouldBreak = true;
        }
        // get the line string clean of comments (anything after the first found hashtag is deleted)
        std::string line = remove_comments(text.substr(lineStart, lineEnd - lineStart));

        // if it is just whitespace, ignore and get next line
        if (line_is_empty(line)) {
            lineStart = lineEnd + 1;
            lineEnd = text.find('\n', lineStart);
            lineNb++;
            continue;
        }
        // get the line indent type and size
        IndentType lineIndentType = indent_type_of_line(line);
        size_t lineIndentSize = indent_size_of_line(line);

        // check for IndentType::invalid indent
        if (lineIndentType != IndentType::NoIndent &&
            lineIndentType != indentType) {    // indent different from the one chosen at the start of the file
            logger.err("ERROR") << " at line " << lineNb + 1 << ": " << line;
            throw InvalidIndentException("Different indent than the one defined at start of file.");
        }
        if (lineIndentSize != 0 && lineIndentSize % indentSize != 0) {    // not a multiple of indent size
            logger.err("ERROR") << " at line " << lineNb + 1 << ": " << line;
            throw InvalidIndentException("Indent size is not correct.");
        }
        // create Indent / Unindent tokens if file has indent
        if (indentSize != 0) {
            // create Indent token(s) if lineIndent is strictly greater than last line indent
            if ((lineIndentSize / indentSize) > (lastLineIndentSize / indentSize))
                for (size_t i = 0; i < ((lineIndentSize / indentSize) - (lastLineIndentSize / indentSize));
                     i++)    // one token per indent (4 IndentType::spaces indent, 8 IndentType::spaces in line => 2
                             // indent tokens)
                    _tokens.push(Token{.type = TokenType::Indent,
                                       .value = "Indent",
                                       .line_nb = lineNb,
                                       .char_nb = i * indentSize + lastLineIndentSize + 1});
            // create Dedent token(s) if lineIndent is strictly lower than last line indent
            if ((lineIndentSize / indentSize) < (lastLineIndentSize / indentSize))
                for (size_t i = 0; i < ((lastLineIndentSize / indentSize) - (lineIndentSize / indentSize));
                     i++)    // one token per dedent (4 IndentType::spaces dedent, 8 IndentType::spaces in line => 2
                             // dedent tokens)
                    _tokens.push(Token{.type = TokenType::Dedent,
                                       .value = "Dedent",
                                       .line_nb = lineNb,
                                       .char_nb = i * indentSize + lastLineIndentSize + 1});
        }
        lastLineIndentSize = lineIndentSize;

        // create all other tokens
        size_t lcursor = line.find_first_not_of(" \t");
        size_t rcursor = line.find_first_of(gKnownSymbols, lcursor);
        while (rcursor != std::string::npos) {    // Find every known symbol, and add either it or the string up until
                                                  // it to the tokens
            if (rcursor == lcursor && !isdigit(line.at(lcursor))) {    // token is the found symbol

                if (line.at(lcursor) == '"') {                // double quoted string start
                    rcursor = line.find('"', lcursor + 1);    // find the end to the double quote string
                    if (rcursor ==
                        std::string::npos) {    // no more '"' on the line, multi-line quoted strings unsupported yet.
                                                // pretend the string ends at the end of the line
                        std::string literalString = unescapeChars(line.substr(lcursor));
                        _tokens.push(Token{.type = TokenType::DoubleQuotedString,
                                           .value = literalString,
                                           .line_nb = lineNb,
                                           .char_nb = lcursor + 1});
                        lcursor = line.size();    // end of line
                        continue;    // no more tokens on the line, and rcursor == std::string::npos, go to next line
                    } else {         // the quote ends on the same line
                        // save raw value without the '"'
                        std::string literalString = unescapeChars(line.substr(lcursor + 1, rcursor - lcursor - 1));
                        _tokens.push(Token{.type = TokenType::DoubleQuotedString,
                                           .value = literalString,
                                           .line_nb = lineNb,
                                           .char_nb = lcursor + 1});
                        lcursor = rcursor + 1;
                        rcursor = line.find_first_of(gKnownSymbols, lcursor);    // TODO: better logic than continue
                        continue;
                    }
                }    // all branches led to continue

                if (!std::isspace(line.at(rcursor))) {    // token is not whitespace
                    if (gTwoCharOps.contains(
                            line.substr(lcursor, 2))) {    // token is logical / relational operator ( 2 char wide)
                        _tokens.push(Token{.type = TokenType::Symbol,
                                           .value = line.substr(lcursor, 2),
                                           .line_nb = lineNb,
                                           .char_nb = lcursor});
                        lcursor = rcursor + 2;
                        rcursor = line.find_first_of(gKnownSymbols, lcursor);
                    } else {    // token is just a symbol
                        _tokens.push(Token{.type = TokenType::Symbol,
                                           .value = line.substr(lcursor, 1),
                                           .line_nb = lineNb,
                                           .char_nb = lcursor + 1});
                        lcursor = rcursor + 1;
                        rcursor = line.find_first_of(gKnownSymbols, lcursor);
                    }
                } else {    // token is whitespace
                    lcursor = rcursor + 1;
                    rcursor = line.find_first_of(gKnownSymbols, lcursor);
                }

            } else {    // tokens are the string up until the symbol, and the symbol itself
                std::string tokenStr = line.substr(lcursor, rcursor - lcursor);
                bool isLastToken = false;
                try {                                          // if token is a literal number, store it as that
                    static_cast<void>(std::stod(tokenStr));    // check integral part is a number
                    if (line.at(rcursor) == '.') {             // handle decimal literals
                        rcursor = line.find_first_of(gKnownSymbols, rcursor + 1);
                        isLastToken = (rcursor == std::string::npos);
                        rcursor = ((rcursor == std::string::npos) ? line.size() : rcursor);
                        tokenStr = line.substr(lcursor, rcursor - lcursor);
                        static_cast<void>(std::stod(tokenStr));    // check full decimal number
                    }
                    _tokens.push(Token{.type = TokenType::LiteralNumber,
                                       .value = tokenStr,
                                       .line_nb = lineNb,
                                       .char_nb = lcursor + 1});
                } catch (const std::invalid_argument &) {    // token is not a number
                    if (tokenStr == "True" || tokenStr == "False") {
                        _tokens.push(Token{
                            .type = TokenType::Boolean, .value = tokenStr, .line_nb = lineNb, .char_nb = lcursor + 1});
                    } else {
                        _tokens.push(Token{.type = TokenType::Identifier,
                                           .value = tokenStr,
                                           .line_nb = lineNb,
                                           .char_nb = lcursor + 1});
                    }
                } catch (const std::out_of_range &) {    // token is invalid number
                    // std::cerr << std::format("Token {} is too big to go into a double. Will be stored as literal
                    // string.", tokenStr) << std::endl;
                    logger.warn("Token ")
                        << tokenStr
                        << " is too big to go into a double. Will be stored as literal string.";    // format not
                                                                                                    // available in
                                                                                                    // c++20 gcc yet
                    _tokens.push(Token{
                        .type = TokenType::Identifier, .value = tokenStr, .line_nb = lineNb, .char_nb = lcursor + 1});
                }
                if (!isLastToken && !std::isspace(line.at(rcursor)))
                    _tokens.push(Token{.type = TokenType::Symbol,
                                       .value = line.substr(rcursor, 1),
                                       .line_nb = lineNb,
                                       .char_nb = rcursor + 1});
                lcursor = rcursor + 1;
                rcursor = line.find_first_of(gKnownSymbols, lcursor);
            }
        }
        if (lcursor < line.size()) {    // TODO : handle last token more elegantly ?
            std::string tokenStr = line.substr(lcursor, rcursor - lcursor);
            try {                                          // if token is a literal number, store it as that
                static_cast<void>(std::stod(tokenStr));    // check integral part is a number
                _tokens.push(Token{
                    .type = TokenType::LiteralNumber, .value = tokenStr, .line_nb = lineNb, .char_nb = lcursor + 1});
            } catch (const std::invalid_argument &) {    // token is not a number
                if (tokenStr == "True" || tokenStr == "False") {
                    _tokens.push(Token{
                        .type = TokenType::Boolean, .value = tokenStr, .line_nb = lineNb, .char_nb = lcursor + 1});
                } else {
                    _tokens.push(Token{
                        .type = TokenType::Identifier, .value = tokenStr, .line_nb = lineNb, .char_nb = lcursor + 1});
                }
            } catch (const std::out_of_range &) {    // token is invalid number
                // std::cerr << std::format("Token {} is too big to go into a double. Will be stored as literal
                // string.", tokenStr) << std::endl;
                logger.warn("Token ")
                    << tokenStr
                    << " is too big to go into a double. Will be stored as literal string.";    // format not
                                                                                                // available in
                                                                                                // c++20 gcc yet
                _tokens.push(
                    Token{.type = TokenType::Identifier, .value = tokenStr, .line_nb = lineNb, .char_nb = lcursor + 1});
            }
        }
        lineStart = lineEnd + 1;
        lineEnd = text.find('\n', lineStart);
        lineNb++;
    }
}

// Private methods
Node Parser::consumeEvent()
{    // Consume an event token and all following to build an event declaration node
    Node result = {.type = NodeType::EventDeclaration};
    if (_tokens.size() <= 1) {    // Tokens only contains ["event"]
        logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb << ": '"
                            << _tokens.front().value << "'";
        throw UnexpectedEOFException("Expected new event declaration");
    }
    Token last = _tokens.front();
    result.line_nb = last.line_nb;
    result.char_nb = last.char_nb;
    _tokens.pop();    // Delete 'event' token

    consumeEventToken(result, TokenType::Identifier, NodeType::EventName,
                      last);    // consume 'eventName' token
    if (_tokens.empty()) {      // Expect at least one parameter
        logger.err("ERROR") << " at line " << last.line_nb << " char " << last.char_nb << ": '" << last.value << "'";
        throw UnexpectedEOFException("Expected event parameter");
    }
    if (_tokens.front().type == TokenType::Indent) {    // Multiline event declaration
        _tokens.pop();                                  // Delete Indent token
        // Iterate over all tokens until either end of file, Dedent token or other declaration
        // Remove tokens line by line, either groups of components, or "Type Name" payload
        while (_tokens.size() > 0 && _tokens.front().value != "component" && _tokens.front().value != "system" &&
               _tokens.front().value != "event" && _tokens.front().type != TokenType::Dedent) {
            if (gVariableTypes.contains(
                    _tokens.front().value)) {    // if token is a pivotscript type, this is the payload
                consumeEventToken(result, TokenType::Identifier, NodeType::EventPayloadType, last);
                consumeEventToken(result, TokenType::Identifier, NodeType::EventPayloadName, last);
            } else {    // otherwise it is a group of components
                Node entityParameterResult = {.type = NodeType::EventEntityParameter};
                while (!_tokens.empty()) {    // iterate over every component from that group
                    consumeEventToken(entityParameterResult, TokenType::Identifier, NodeType::EventEntityComponent,
                                      last);
                    if (_tokens.empty() || _tokens.front().line_nb != last.line_nb ||
                        _tokens.front().type == TokenType::Dedent)    // end of event declaration
                        break;
                    expectSystemTokenValue(",", last, true);    // expect ',' token to separate component parameters
                }
                result.children.push_back(
                    entityParameterResult);    // push the entity parameter to the event description
            }
        }
        if (_tokens.size() > 0) {                               // File still has content
            if (_tokens.front().type != TokenType::Dedent) {    // But no Dedent token
                logger.err("ERROR") << " at line " << last.line_nb << " char " << last.char_nb << ": '" << last.value
                                    << "'";
                throw UnexpectedTokenTypeException("Expected a Dedent token");
            }
            _tokens.pop();    // Erase Dedent token
        }
    } else {                                                                     // Single line event declaration
        consumeEventToken(result, TokenType::Symbol, NodeType::Symbol, last);    // expect "=" symbol
        consumeEventToken(result, TokenType::Identifier, NodeType::EventPayloadType, last);
        consumeEventToken(result, TokenType::Identifier, NodeType::EventPayloadName, last);
    }
    return result;
}
void Parser::consumeEventToken(Node &result, TokenType expectedType, NodeType fillType, Token &lastToken)
{    // consume one token
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        throw UnexpectedEOFException("Expected event entity parameter, or payload, or end of declaration");
    }
    if (_tokens.front().type != expectedType) {
        logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb << ": '"
                            << _tokens.front().value << "'";
        logger.err("Expected ") << magic_enum::enum_name(expectedType) << " token";
        throw UnexpectedTokenTypeException("Invalid type for token.");
    }
    if (fillType == NodeType::EventName)    // The event name is stored in the value of the node
        result.value = _tokens.front().value;
    else    // but its parameters are stored in the children node
        result.children.push_back(Node{.type = fillType,
                                       .value = _tokens.front().value,
                                       .line_nb = _tokens.front().line_nb,
                                       .char_nb = _tokens.front().char_nb});
    // consume the token
    lastToken = _tokens.front();
    _tokens.pop();
}

Node Parser::consumeComponent()
{    // Consume a component token and all following to build a component declaration node
    DEBUG_FUNCTION();
    Node result = {.type = NodeType::ComponentDeclaration};
    if (_tokens.size() <= 1) {    // Tokens only contains ["component"]
        logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb << ": '"
                            << _tokens.front().value << "'";
        throw UnexpectedEOFException("Expected new component declaration");
    }
    Token last = _tokens.front();
    result.line_nb = last.line_nb;
    result.char_nb = last.char_nb;
    _tokens.pop();    // Delete 'component' token

    consumeComponentToken(result, TokenType::Identifier, NodeType::ComponentName,
                          last);    // consume 'componentName' token
    if (_tokens.empty()) {          // Expect at least one property
        logger.err("ERROR") << " at line " << last.line_nb << " char " << last.char_nb << ": '" << last.value << "'";
        throw UnexpectedEOFException("Expected component property");
    }
    if (_tokens.front().type == TokenType::Indent) {    // Multiline component declaration
        _tokens.pop();                                  // Delete Indent token
        // Iterate over all tokens until either end of file, Dedent token or other declaration
        // Remove tokens two by two, by expecting "Type Name" tokens
        while (_tokens.size() > 0 && _tokens.front().value != "component" && _tokens.front().value != "system" &&
               _tokens.front().value != "event" && _tokens.front().type != TokenType::Dedent) {
            consumeComponentToken(result, TokenType::Identifier, NodeType::PropertyType, last);
            consumeComponentToken(result, TokenType::Identifier, NodeType::PropertyName, last);
        }
        if (_tokens.size() > 0) {                               // File still has content
            if (_tokens.front().type != TokenType::Dedent) {    // But no Dedent token
                logger.err("ERROR") << " at line " << last.line_nb << " char " << last.char_nb << ": '" << last.value
                                    << "'";
                throw UnexpectedTokenTypeException("Expected a Dedent token");
            }
            _tokens.pop();    // Erase Dedent token
        }
    } else {    // Single line component declaration
        consumeComponentToken(result, TokenType::Symbol, NodeType::Symbol, last);
        consumeComponentToken(result, TokenType::Identifier, NodeType::PropertyType, last);
    }
    return result;
}
void Parser::consumeComponentToken(Node &result, TokenType expectedType, NodeType fillType, Token &lastToken)
{    // consume one token
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        throw UnexpectedEOFException("Expected component property type or end of declaration");
    }
    if (_tokens.front().type != expectedType) {
        logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb << ": '"
                            << _tokens.front().value << "'";
        logger.err("Expected ") << magic_enum::enum_name(expectedType) << " token";
        throw UnexpectedTokenTypeException("Invalid type for token.");
    }
    // The component name is stored in the value of the node
    if (fillType == NodeType::ComponentName)
        result.value = _tokens.front().value;
    else    // but its properties are stored in the children node
        result.children.push_back(Node{.type = fillType,
                                       .value = _tokens.front().value,
                                       .line_nb = _tokens.front().line_nb,
                                       .char_nb = _tokens.front().char_nb});
    // consume the token
    lastToken = _tokens.front();
    _tokens.pop();
}
Node Parser::consumeSystem()
{    // Consume a system token and all following to build a system declaration node
    DEBUG_FUNCTION();
    Node result = {.type = NodeType::SystemDeclaration};
    if (_tokens.size() <= 1) {    // Tokens only contains ["system"]
        logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb << ": '"
                            << _tokens.front().value << "'";
        throw UnexpectedEOFException("Expected system name");
    }
    Token last = _tokens.front();
    result.line_nb = last.line_nb;
    result.char_nb = last.char_nb;
    _tokens.pop();    // Delete 'system' token

    // Consume all components for the description
    consumeSystemDescriptionToken(result, TokenType::Identifier, NodeType::SystemName,
                                  last);                                                 // Consume system name
    consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol, last);    // Consume '(' symbol
    if (isDeclarationOver()) {    // Expect at least one entity parameter
        logger.err("ERROR") << " at line " << last.line_nb << " char " << last.char_nb << ": '" << last.value << "'";
        throw UnexpectedEOFException("Expected system entity parameter");
    }
    while (_tokens.size() > 0 &&
           _tokens.front().value != ")") {    // Consume all entity parameters ,up until next ')' symbol
        consumeSystemDescriptionToken(result, TokenType::Identifier, NodeType::EntityParameterName,
                                      last);    // Consume entity parameter name
        consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol,
                                      last);    // Consume '<' symbol
        while (_tokens.size() > 0 &&
               _tokens.front().value != ">") {    // Consume all entity parameter components, up until next '>' symbol
            consumeSystemDescriptionToken(result, TokenType::Identifier, NodeType::EntityParameterComponent,
                                          last);                       // Consume component name
            if (_tokens.size() > 0 && _tokens.front().value == ">")    // no more ',', end of loop
                break;
            consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol,
                                          last);    // Consume ',' symbol
        }
        consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol,
                                      last);    // Consume '>' symbol
    }
    consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol, last);    // Consume ')' symbol
    // event is optional, if declaration is over use a default Tick event
    if (isDeclarationOver() || _tokens.front().type == TokenType::Dedent) return result;
    // custom event
    consumeSystemDescriptionToken(result, TokenType::Identifier, NodeType::EventKeyword,
                                  last);    // Consume "event" keyword
    consumeSystemDescriptionToken(result, TokenType::Identifier, NodeType::EventName,
                                  last);    // Consume 'eventName' identifier
    consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol, last);    // Consume '(' symbol
    while (_tokens.size() > 1 &&
           _tokens.front().value != ")") {    // Consume all event parameters, up until next ')' symbol

        // Need the second element, but queue is not made for this access
        // Pop the first and keep it in memory to pass it as parameter
        Token varName = _tokens.front();
        _tokens.pop();

        if (_tokens.front().value == "<") {    // Parameter is entity parameter

            // Use overload to circumvent the nature of queue object
            consumeSystemDescriptionToken(varName, result, TokenType::Identifier, NodeType::EventEntityName,
                                          last);    // consume entity name
            consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol,
                                          last);    // Consume '<' symbol
            while (_tokens.size() > 0 &&
                   _tokens.front().value != ">") {    // Consume all event entity component parameters
                consumeSystemDescriptionToken(result, TokenType::Identifier, NodeType::EventEntityComponent, last);
                if (_tokens.size() > 0 && _tokens.front().value == ">")    // no more ',' end of loop
                    break;
                consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol,
                                              last);    // Consume ',' symbol
            }
            consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol,
                                          last);    // Consume '>' symbol
        } else {                                    // Parameter is payload
            // Use overload to circumvent the nature of queue object
            consumeSystemDescriptionToken(varName, result, TokenType::Identifier, NodeType::EventPayloadType,
                                          last);    // Consume event payload type
            consumeSystemDescriptionToken(result, TokenType::Identifier, NodeType::EventPayloadName,
                                          last);    // Consume event payload name
        }
        if (_tokens.size() > 0 && _tokens.front().value == ")")    // no more ',', end of loop
            break;
        consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol,
                                      last);    // Consume ',' symbol
    }
    consumeSystemDescriptionToken(result, TokenType::Symbol, NodeType::Symbol, last);    // Consume ')' symbol
    // End of system description

    // Start of system execution code
    expectSystemToken(TokenType::Indent, last, true);    // should start with indent
    Node systemEntry = {.type = NodeType::SystemEntryPoint,
                        .value = result.value,
                        .line_nb = result.line_nb,
                        .char_nb = result.char_nb};
    while (!isDeclarationOver())                      // system is list of statements
        consumeSystemStatement(systemEntry, last);    // expect statements until end of declaration
    result.children.push_back(systemEntry);
    return result;
}
void Parser::consumeSystemDescriptionToken(Node &result, TokenType expectedType, NodeType fillType, Token &lastToken)
{    // consume one token for declaration (front of queue)
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        logger.err("Expected ") << magic_enum::enum_name(expectedType) << "token";
        throw UnexpectedEOFException("");
    }
    if (_tokens.front().type != expectedType) {
        logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb << ": '"
                            << _tokens.front().value << "'";
        logger.err("Expected ") << magic_enum::enum_name(expectedType) << "token";
        throw UnexpectedTokenTypeException("");
    }
    // The system name is stored in the value
    if (fillType == NodeType::SystemName)
        result.value = _tokens.front().value;
    else    // TODO: implement `data : variant(map<string, data>, string)` for actual abstract syntax tree parsing
        result.children.push_back(Node{.type = fillType,
                                       .value = _tokens.front().value,
                                       .line_nb = _tokens.front().line_nb,
                                       .char_nb = _tokens.front().char_nb});
    lastToken = _tokens.front();
    _tokens.pop();
}
void Parser::consumeSystemDescriptionToken(const Token &token, Node &result, TokenType expectedType, NodeType fillType,
                                           Token &lastToken)
{    // consume one token for declaration (parameter)
    DEBUG_FUNCTION();
    if (token.type != expectedType) {
        logger.err("ERROR") << " at line " << token.line_nb << " char " << token.char_nb << ": '" << token.value << "'";
        logger.err("Expected ") << magic_enum::enum_name(expectedType) << "token";
        throw UnexpectedTokenTypeException("");
    }
    // The system name is stored in the value
    if (fillType == NodeType::SystemName)
        result.value = token.value;
    else    // TODO: implement `data : variant(map<string, data>, string)` for actual abstract syntax tree parsing
        result.children.push_back(
            Node{.type = fillType, .value = token.value, .line_nb = token.line_nb, .char_nb = token.char_nb});
    lastToken = token;
}
void Parser::consumeSystemStatement(Node &result, Token &lastToken)
{    // consume an entire statement and append it to children node
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        throw UnexpectedEOFException("Expected statement");
    }
    const Token &token = _tokens.front();
    Node statementResult = {.type = NodeType::Statement, .line_nb = token.line_nb, .char_nb = token.char_nb};
    if (std::find(gBlockops.begin(), gBlockops.end(), token.value) != gBlockops.end()) {    // Is block operator
        statementResult.value = token.value;    // store the "if","while","for" for the interpreter
        consumeSystemBlock(statementResult, lastToken);
    } else if (token.value == "emit") {
        statementResult.value = "emit";                      // store the "if","while","for" for the interpreter
        consumeEmitStatement(statementResult, lastToken);    // line starts with variable
    } else {
        consumeSystemVariable(statementResult, lastToken);    // line starts with variable
        if (_tokens.front().value == "=") {                   // assign expression to variable
            statementResult.value = "assign";                 // store the type of statement for the interpreter
            // statementResult.children.push_back(Node {.type=NodeType::Symbol, .value=_tokens.front().value,
            // .line_nb=_tokens.front().line_nb, .char_nb=_tokens.front().char_nb});
            Node expressionNode = {
                .type = NodeType::Expression, .line_nb = _tokens.front().line_nb, .char_nb = _tokens.front().char_nb};
            lastToken = _tokens.front();
            _tokens.pop();    // delete '=' token
            consumeSystemExpression(expressionNode,
                                    lastToken);    // consume the expression to assign to variable
            statementResult.children.push_back(expressionNode);
        } else if (_tokens.front().value == "(") {     // variable calls a function
            statementResult.value = "functionCall";    // store the type of statement for the interpreter
            consumeSystemFuncParams(statementResult, lastToken);

        } else {    // unsupported features
            logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb
                                << ": '" << _tokens.front().value << "'";
            throw UnexpectedTokenValueException(
                "Not '=' nor '(', unsupported yet. pivot::ecs::script::parser::consumeSystemStatement()");
        }
    }
    result.children.push_back(statementResult);
}
void Parser::consumeEmitStatement(Node &result, [[maybe_unused]] Token &lastToken)
{
    Node emitEvent = {
        .type = NodeType::EmitEvent,
        .line_nb = _tokens.front().line_nb,
        .char_nb = _tokens.front().char_nb,
    };

    _tokens.pop();

    auto eventToken = _tokens.front();
    if (eventToken.type != TokenType::Identifier) { throw UnexpectedTokenTypeException("Expected event name"); }
    emitEvent.value = eventToken.value;
    _tokens.pop();

    consumeSystemFuncParams(emitEvent, eventToken);

    result.children.push_back(emitEvent);
}
void Parser::consumeSystemBlock(Node &result, Token &lastToken)
{    // consume entire block and append it to children node
    DEBUG_FUNCTION();
    Node blockCondition = {.type = NodeType::Expression,
                           .value = "condition",
                           .line_nb = _tokens.front().line_nb,
                           .char_nb = _tokens.front().char_nb};
    lastToken = _tokens.front();
    _tokens.pop();                                         // Remove "if","while" token
    consumeSystemExpression(blockCondition, lastToken);    // consume condition as expression
    result.children.push_back(blockCondition);             // add the condition to tree as children of block node

    expectSystemToken(TokenType::Indent, lastToken, true);                     // start of block
    while (_tokens.size() > 0 && _tokens.front().type != TokenType::Dedent)    // loop over block
        consumeSystemStatement(result, lastToken);    // recursively consume all statements in the block
    if (_tokens.size() != 0) expectSystemToken(TokenType::Dedent, lastToken, true);    // end of block
}
void Parser::consumeSystemVariable(Node &result, Token &lastToken)
{    // consume a variable and append it to children node
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        throw UnexpectedEOFException("Expected variable");
    }
    Token &token = _tokens.front();
    Node variableResult = {.line_nb = token.line_nb, .char_nb = token.char_nb};
    if (token.type == TokenType::LiteralNumber) {    // literal number
        variableResult.type = NodeType::LiteralNumberVariable;
        variableResult.value = token.value;    // store the value directly
        lastToken = _tokens.front();
        _tokens.pop();
    } else if (token.type == TokenType::Boolean) {    // Boolean, "True" "False"
        variableResult.type = NodeType::Boolean;
        variableResult.value = token.value;
        lastToken = _tokens.front();
        _tokens.pop();
    } else if (token.type == TokenType::DoubleQuotedString) {    // "string"
        variableResult.type = NodeType::DoubleQuotedStringVariable;
        variableResult.value = token.value;
        lastToken = _tokens.front();
        _tokens.pop();
    } else if (gVariableTypes.contains(token.value)) {    // variable declaration
        variableResult.type = NodeType::NewVariable;
        variableResult.children.push_back(Node{.type = NodeType::Type,
                                               .value = token.value,
                                               .line_nb = token.line_nb,
                                               .char_nb = token.char_nb});    // type node
        lastToken = _tokens.front();
        _tokens.pop();    // remove the type token
        expectSystemToken(TokenType::Identifier, lastToken,
                          false);    // expect an identifier (name for the variable)
        variableResult.children.push_back(Node{.type = NodeType::Name,
                                               .value = _tokens.front().value,
                                               .line_nb = _tokens.front().line_nb,
                                               .char_nb = _tokens.front().char_nb});
        lastToken = _tokens.front();
        _tokens.pop();    // remove the name token
    } else {              // variable
        variableResult.type = NodeType::ExistingVariable;
        variableResult.value = "";
        // Take into account all identifiers and symbols which are "."
        while (_tokens.size() > 0) {
            Token &varToken = _tokens.front();
            if (varToken.type == TokenType::Identifier) variableResult.value += varToken.value;
            // variableResult.children.push_back(Node {.type=NodeType::Name, .value=varToken.value,
            // .line_nb=varToken.line_nb, .char_nb=varToken.char_nb});
            else if (varToken.type == TokenType::Symbol && varToken.value == ".")
                variableResult.value += varToken.value;
            // variableResult.children.push_back(Node {.type=NodeType::Symbol, .value=varToken.value,
            // .line_nb=varToken.line_nb, .char_nb=varToken.char_nb});
            else
                break;
            lastToken = _tokens.front();
            _tokens.pop();    // delete token
            if (_tokens.size() > 0 && _tokens.front().line_nb != lastToken.line_nb) break;
        }
        // if (variableResult.children.size() == 1 && variableResult.children.at(0).type == NodeType::Name)
        // 	variableResult.value = variableResult.children.at(0).value;
    }
    result.children.push_back(variableResult);
}
void Parser::consumeSystemExpression(Node &result, Token &lastToken)
{    // consume an expression and append it to children node
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        throw UnexpectedEOFException("Expected expression");
    }

    // An expression is a construct of Operand Operator Operand...etc that can be solved to a single operand
    // An expression ends with a newline or until a stopping symbol ','
    // We will single-traverse the expression, and translate it to a postfix architecture
    // This takes care of precedence of operation and eases the work of the interpreter
    // The postfix result is represented as the result's children
    int parenthesesCounts = 0;
    std::stack<Token> _stack;    // storage for operators during postfix
    while (!_tokens.empty() && _tokens.front().line_nb == result.line_nb && _tokens.front().value != "," &&
           (_tokens.front().value != ")" || parenthesesCounts != 0)) {    // an expression runs until the next line
                                                                          // or until stopping symbol (','
                                                                          //  or ')' that hasn't been opened)
        if (_tokens.front().type != TokenType::Symbol) {
            // consumeSystemVariable(result, lastToken);    // consume operand as variable into postfix result
            // if (!_tokens.empty() && _tokens.front().value == "(") {
            //     std::cout << "function call " << std::endl;
            // }
            consumeSystemVarOrFunc(result, lastToken);
        }
        if (_tokens.empty() || _tokens.front().line_nb != result.line_nb || _tokens.front().value == "," ||
            (_tokens.front().value == ")" &&
             parenthesesCounts == 0)) {    // no more tokens/operators, end of expression
            while (
                !_stack.empty()) {    // At the end of infix expression, we push all stack operators into postfix result
                result.children.push_back(Node{.type = NodeType::Operator,
                                               .value = _stack.top().value,
                                               .line_nb = _stack.top().line_nb,
                                               .char_nb = _stack.top().char_nb});
                _stack.pop();
            }
            break;
        }
        if (_tokens.front().type != TokenType::Symbol &&
            _tokens.front().type != TokenType::Dedent) {    // token is not an operator or dedent
            logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb
                                << ": '" << _tokens.front().value << "'";
            throw UnexpectedTokenTypeException("Expected operator symbol or end of expression");
        }
        if (_tokens.front().value == "(") {    // opening parentheses
            parenthesesCounts++;               // count opening parentheses
            _stack.push(_tokens.front());
            lastToken = _tokens.front();
            _tokens.pop();                            // delete parentheses token
        } else if (_tokens.front().value == ")") {    // closing parentheses
            parenthesesCounts--;                      // un-count opening parentheses
            while (!_stack.empty() &&
                   _stack.top().value !=
                       "(") {    // pop all operators to postfix result until innermost opening parentheses
                result.children.push_back(Node{.type = NodeType::Operator,
                                               .value = _stack.top().value,
                                               .line_nb = _stack.top().line_nb,
                                               .char_nb = _stack.top().char_nb});
                _stack.pop();
            }
            _stack.pop();    // pop '('
            lastToken = _tokens.front();
            _tokens.pop();
        } else if (gOneCharOps.contains(_tokens.front().value) ||
                   gTwoCharOps.contains(_tokens.front().value)) {    // normal operator
            while (!_stack.empty() && _stack.top().value != "(" &&
                   hasHigherPrecedence(
                       _stack.top().value,
                       _tokens.front().value)) {    // pop all operators from stack with high precedence of operation
                result.children.push_back(Node{.type = NodeType::Operator,
                                               .value = _stack.top().value,
                                               .line_nb = _stack.top().line_nb,
                                               .char_nb = _stack.top().char_nb});
                _stack.pop();
            }
            _stack.push(_tokens.front());
            lastToken = _tokens.front();
            _tokens.pop();    // delete operator token
        } else {
            logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb
                                << ": '" << _tokens.front().value << "'";
            throw UnexpectedTokenTypeException("Expected operator symbol");
        }
    }
    while (!_stack.empty()) {    // pop all operators to postfix result
        result.children.push_back(Node{.type = NodeType::Operator,
                                       .value = _stack.top().value,
                                       .line_nb = _stack.top().line_nb,
                                       .char_nb = _stack.top().char_nb});
        _stack.pop();
    }
}
void Parser::consumeSystemFuncParams(Node &result, Token &lastToken)
{    // consume function parameters and append them to children node
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        throw UnexpectedEOFException("Expected '(' symbol");
    }
    Node paramsResult = {
        .type = NodeType::FunctionParams, .line_nb = _tokens.front().line_nb, .char_nb = _tokens.front().char_nb};
    expectSystemTokenValue("(", lastToken, true);
    // Function parameters is either nothing, or a list of expressions, separated by commas, until a ')' symbol
    // TODO : handle parentheses '(' ')'
    while (_tokens.size() > 0 && _tokens.front().value != ")") {    // an expression runs until a ')' symbol
        // consumeSystemVariable(paramsResult, lastToken);             // consume variable
        Node expressionResult = {
            .type = NodeType::Expression, .line_nb = _tokens.front().line_nb, .char_nb = _tokens.front().char_nb};
        consumeSystemExpression(expressionResult, lastToken);
        paramsResult.children.push_back(expressionResult);
        if (_tokens.empty() || _tokens.front().value == ")")    // no more variables, end of expression
            break;
        if (_tokens.front().value != ",") {    // token is not an comma
            logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb
                                << ": '" << _tokens.front().value << "'";
            throw UnexpectedEOFException("Expected comma");
        }
        // paramsResult.children.push_back(Node {.type=NodeType::Symbol, .value=_tokens.front().value,
        // .line_nb=_tokens.front().line_nb, .char_nb=_tokens.front().char_nb});
        lastToken = _tokens.front();
        _tokens.pop();    // delete ',' token
    }
    expectSystemTokenValue(")", lastToken, true);
    result.children.push_back(paramsResult);
}

void Parser::consumeSystemVarOrFunc(Node &result, Token &lastToken)
{
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        throw UnexpectedEOFException("Expected variable or function call");
    }
    Token &token = _tokens.front();
    Node resultNode = {.line_nb = token.line_nb, .char_nb = token.char_nb};
    consumeSystemVariable(resultNode, lastToken);              // expect a variable
    if (!_tokens.empty() && _tokens.front().value == "(") {    // function call
        resultNode.type = NodeType::FunctionCall;
        consumeSystemFuncParams(resultNode, lastToken);
        result.children.push_back(resultNode);                   // push a function call node
    } else {                                                     // only variable
        result.children.push_back(resultNode.children.at(0));    // push a variable node
    }
}

void Parser::expectSystemToken(TokenType expectedType, Token &lastToken, bool consume)
{    // check that token exists, and is of correct type (and potentially consume it from tokens)
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        logger.err("Expected ") << magic_enum::enum_name(expectedType) << " token type.";
        throw UnexpectedEOFException("");
    }
    if (_tokens.front().type != expectedType) {
        logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb << ": '"
                            << _tokens.front().value << "'";
        logger.err("Expected ") << magic_enum::enum_name(expectedType) << " token type.";
        throw UnexpectedTokenTypeException("");
    }
    if (consume) {
        lastToken = _tokens.front();
        _tokens.pop();
    }
}
void Parser::expectSystemTokenValue(const std::string &expectedValue, Token &lastToken, bool consume)
{    // check that token exists, and is of correct value (and potentially consume it from tokens)
    DEBUG_FUNCTION();
    if (_tokens.empty()) {
        logger.err("ERROR") << " at line " << lastToken.line_nb << " char " << lastToken.char_nb << ": '"
                            << lastToken.value << "'";
        logger.err("Expected '") << expectedValue << "' token value.";
        throw UnexpectedEOFException("");
    }
    if (_tokens.front().value != expectedValue) {
        logger.err("ERROR") << " at line " << _tokens.front().line_nb << " char " << _tokens.front().char_nb << ": '"
                            << _tokens.front().value << "'";
        logger.err("Expected '") << expectedValue << "' token value.";
        throw UnexpectedTokenValueException("");
    }
    if (consume) {
        lastToken = _tokens.front();
        _tokens.pop();
    }
}

bool Parser::isDeclarationOver()
{    // Is there no more tokens, or is the first the end of the declaration
    DEBUG_FUNCTION();
    if (_tokens.empty())    // No more tokens
        return true;
    if (_tokens.front().value == "component" ||
        _tokens.front().value == "system")    // First token is "component" "system"
        return true;
    return false;
}

// Private functions (used only in this file, present in header for test purposes)

bool hasHigherPrecedence(const std::string &op, const std::string &compareTo)
{    // Does the op have higher precedence ( or priority ) than compareTo
    return precedenceOf(op) > precedenceOf(compareTo);
}

Precedence precedenceOf(const std::string &op)
{    // Get a number representing the priority of op
    if (gOneCharOps.contains(op)) return gOneCharOps.at(op);
    if (gTwoCharOps.contains(op)) return gTwoCharOps.at(op);

    // unlikely branch (impossible?)
    logger.err("ERROR") << " with operator '" << op << "'";
    throw std::invalid_argument("Expected operator symbol in precendenceOf(const std::string &)");
}

size_t indent_size_of(const std::string &fileString)
{    // Detect indent size of file content
    size_t lineStart = 0;
    size_t lineEnd = fileString.find('\n');
    bool shouldBreak = false;

    while (!shouldBreak) {
        if (lineEnd == std::string::npos) {     // TODO : handle last line more elegantly ?
            lineEnd = fileString.size() - 1;    // last line of file
            shouldBreak = true;
        }
        // get the line string clean of comments (anything after the first found hashtag is deleted)
        std::string line = remove_comments(fileString.substr(lineStart, lineEnd - lineStart));

        // if it is just whitespace, ignore and get next line
        if (line_is_empty(line)) {
            lineStart = lineEnd + 1;
            lineEnd = fileString.find('\n', lineStart);
            continue;
        }
        size_t r = indent_size_of_line(line);
        if (r != 0) return r;
        lineStart = lineEnd + 1;
        lineEnd = fileString.find('\n', lineStart);
    }
    return 0;
}
size_t indent_size_of_line(const std::string &fileLine)
{    // for a single line
    for (size_t i = 0; i < fileLine.size(); i++)
        if (fileLine[i] != ' ' && fileLine[i] != '\t') return i;
    return 0;
}

IndentType indent_type_of(const std::string &fileString)
{    // Detect indent type of file content
    size_t lineNb = 0;
    size_t lineStart = 0;
    size_t lineEnd = fileString.find('\n', lineStart);
    bool shouldBreak = false;

    while (!shouldBreak) {
        if (lineEnd == std::string::npos) {     // TODO : handle last line more elegantly ?
            lineEnd = fileString.size() - 1;    // last line of file
            shouldBreak = true;
        }
        // get the line string clean of comments (anything after the first found hashtag is deleted)
        std::string line = remove_comments(fileString.substr(lineStart, lineEnd - lineStart));

        // if it is just whitespace, ignore and get next line
        if (line_is_empty(line)) {
            lineStart = lineEnd + 1;
            lineEnd = fileString.find('\n', lineStart);
            continue;
        }
        IndentType r = indent_type_of_line(line);
        if (r == IndentType::Invalid) {
            logger.err("ERROR") << " at line " << lineNb + 1 << ": " << line;
            throw InvalidIndentException("Invalid indent.");
        }
        if (r != IndentType::NoIndent) return r;
        lineStart = lineEnd + 1;
        lineEnd = fileString.find('\n', lineStart);
        lineNb++;
    }
    return IndentType::NoIndent;
}
IndentType indent_type_of_line(const std::string &fileLine)
{    // for a single line
    if (fileLine.empty()) return IndentType::NoIndent;
    char indentChar = fileLine.at(0);
    IndentType indentType = indent_type_of_char(indentChar);
    if (indentType == IndentType::NoIndent)    // first char is neither a space nor a tab
        return IndentType::NoIndent;
    for (char c: fileLine) {          // indent type has been decided, IndentType::Spaces or IndentType::Tabs
        if (c != ' ' && c != '\t')    // if looped character is neither a space nor a tab, return valid indent
            return indentType;
        if (c != indentChar)    // if looped character isn't the same as first char, return IndentType::invalid indent
            return IndentType::Invalid;
    }
    std::cerr << "Why is this code branch executed ? Parser.cxx :: indent_type_of_line(const std::string &fileLine)"
              << std::endl;
    return IndentType::Invalid;
}
IndentType indent_type_of_char(char c)
{    // for a single char
    return (c == ' ' ? IndentType::Spaces : (c == '\t' ? IndentType::Tabs : IndentType::NoIndent));
}

void printFileNode(const Node &file)
{    // Display a file tree in a readable way
    if (file.type != NodeType::File) {
        // std::cerr << std::format("printFileNode(const Node &file): can't print node {} (not a file)",
        // magic_enum::enum_name(file.type)) << std::endl; // format not available in c++20 gcc yet
        logger.warn("printFileNode(const Node &file): can't print node ")
            << magic_enum::enum_name(file.type) << " (not a file)";
        return;
    }
    // std::cout << std::format("file {}\n", file.value); // format not available in c++20 gcc yet
    std::cout << "file " << file.value << "\n";
    for (const Node &child: file.children)
        // std::cout << std::format("\t{} {}", magic_enum::enum_name(child.type), child.value) << std::endl; // format
        // not available in c++20 gcc yet
        std::cout << "\t" << magic_enum::enum_name(child.type) << " " << child.value << std::endl;
}
void printComponentNode(const Node &component)
{    // Display a component declaration in a readable way
    if (component.type != NodeType::ComponentDeclaration) {
        // std::cerr << std::format("printComponentNode(const Node &component): can't print node {} (not a component)",
        // magic_enum::enum_name(component.type)) << std::endl; // format not available in c++20 gcc yet
        logger.warn("printComponentNode(const Node &component): can't print node ")
            << magic_enum::enum_name(component.type) << " (not a component)";
        return;
    }
    // std::cout << std::format("Component {}", component.value); // format not available in c++20 gcc yet
    std::cout << "Component " << component.value;
    if (component.children.at(0).value == "=")    // Single line component
        // std::cout << std::format(" = {}", component.children.at(1).value) << std::endl; // format not available in
        // c++20 gcc yet
        std::cout << " = " << component.children.at(1).value << std::endl;
    else {
        std::cout << "\n";
        for (size_t i = 0; i < component.children.size() - 2; i += 2)
            // std::cout << std::format("\t{} {}", component.children.at(i).value, component.children.at(i + 1).value)
            // << std::endl; // format not available in c++20 gcc yet
            std::cout << "\t" << component.children.at(i).value << " " << component.children.at(i + 1).value
                      << std::endl;
    }
}
std::string remove_comments(const std::string &line)
{    // Return comment-free version of input
    size_t hashtag = line.find('#');
    if (hashtag == std::string::npos) return line;
    return line.substr(0, hashtag);
}
bool line_is_empty(const std::string &line)
{    // Is line empty
    return line.find_first_not_of(" \t") == std::string::npos;
}

std::string replaceAll(std::string str, const std::string &from, const std::string &to)
{    // Replace all occurences of string 'from' by string 'to' in string 'str'
    size_t start_pos = 0;
    while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length();    // Handles case where 'to' is a substring of 'from'
    }
    return str;
}

std::string unescapeChars(std::string str)
{    // This isn't very clean, but easier to read than regex
    std::string r = replaceAll(str, "\\t", "\t");
    r = replaceAll(r, "\\n", "\n");
    r = replaceAll(r, "\\r", "\r");
    return r;
}

}    // end of namespace pivot::ecs::script::parser
